<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>读懂“2522”，理解数字中国顶层设计</title>
    <link href="/2023/04/24/%E6%95%B0%E5%AD%97%E5%8C%96/"/>
    <url>/2023/04/24/%E6%95%B0%E5%AD%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>今年2月，中共中央、国务院印发的《数字中国建设整体布局规划》。数字化这件事有多重要，咱们不用多说了。过去几年，几乎所有的公司，都在研究数字化转型。毕竟，这是一个大趋势。<br>而《数字中国建设整体布局规划》，命题更大、更深、更关键，它说的是，整个中国的数字化，也就是，数字中国的建设。</p><p>其实，关于这份文件的解读，已经有不少专家做过。这份文件的核心，在于一组数字，叫2522。<br>第一个数字2，指的是做好两大基础，分别是，数字基础设施和数据资源体系。<br>第二个数字5，说的是，推进数字技术与经济、政治、文化、社会、生态文明建设，五位一体的深度融合。<br>第三个数字2，说的是强化数字技术创新体系和数字安全屏障这两大能力。<br>第四个数字2，指的是，优化数字化发展国内和国际这两个环境。</p><img src="/2023/04/24/%E6%95%B0%E5%AD%97%E5%8C%96/2522.png" class="" title="图片引用方法一"><p>2522是方法，而我们的目标，是到2025年，基本形成横向打通、纵向贯通、协调有力的一体化推进格局。到2035年，数字化发展水平进入世界前列，数字中国建设取得重大成就。</p><p>前面这些，每一个词，信息量都很大。为了让你更方便地记住，以及能更直接地解读出蕴藏在其中的机会，今天，我们换个讲法。我专门请教过中央党校，解读重大政策文件的专家。<br>人家告诉我，这类重大文件，假如想更深入地学习了解，不能只看文件本身，还得看前前后后，相关的重大政策。换句话说，我们可以从政策线索出发，来解读这份规划。</p><p>带着这个视角，你会发现，在《数字中国建设整体布局规划》发布之前和之后，都有相关的大动作。咱们先说之前。这份规划是2023年2月发布的。<br>而早在2020年4月，国家发布的《关于构建更加完善的要素市场化配置体制机制的意见》，就已经明确提出了数字要素这个说法。</p><p>要知道，在数字后面，加上要素两个字，意味着什么？这意味着，我们已经正式把数字看成一种生产要素了。在过去的经济学里，生产要素只有四种，分别是，土地、劳动力、资本和技术。<br>而现在，数据已经正式成为第五大生产要素。之后，数据要素又在很多重大会议中被重点提及。</p><p>这是《数字中国建设整体布局规划》发布之前。我们再看之后，就在《规划》发布后不久，有一个重要机构宣布组建，这就是国家数据局。<br>就在今年3月，中共中央、国务院印发了《党和国家机构改革方案》，组建国家数据局。</p><p>你看，从提出说法，到发布规划，再到组建直接的相关机构。这是一个清晰的线路，从构想到设计，从设计到行动。从中，我们能读出一个重点。就是我们在数据管理方面的重点，正在发生转变。<br>之前我国主要是对数据做监管。比如发布《个人信息保护法》和《数据安全法》，这些法案的重点，都在于不能做什么。而数字中国的顶层规划，以及国家数据局的组建，就是在表明，<br>我们数据管理的重点，正在从不能做什么，变成，应该做什么。</p><p>简单说，数字化建设，政府扮演的角色，将从在后监管，变成带头统筹。在今年的两会精神中，也提到过，政府的职责之一，是帮助企业完成高端化、数字化、绿色化升级。<br>而国家数据局的组建，就是要更有效地推动这些事。</p><p>因此，读懂数字中国顶层规划的关键之一，是要了解国家数据局。</p><p>那么，国家数据局的职能定位是什么呢？前段时间，我看一个自媒体，叫人神共奋，勤奋的奋，专门研究过这个问题。</p><p>首先，组建国家数据局，肯定是一个巨大的好消息。为什么？我们都知道，大数据，关键就在一个“大”字。数据需要联通，才能产生一加一大于二的效果。但是你知道，咱们中国最大的数据库在哪？<br>答案是，政府与相关国企。根据之前的统计，我国有80%的数据，都在政府与相关国企的服务器里。比如，城市人口的详细结构数据、商业设施的具体分布数据，等等。</p><p>但问题是，这些数据虽然多，却掌握在不同的部门手里，非常分散。之前还有个说法，叫数据烟囱。指的是，每个政务部门，虽然有大量的数据，但是彼此之间不能共享。<br>就像一根根烟囱，只能在自己的管道里向上冒烟，不能横向打通。之前还有人研究过中国的政务信息化行业，发现中国的政务信息化市场，规模高达4000亿。但最大的IT公司营收，也只有十几亿。<br>你看，乙方小，说明什么？甲方太分散。</p><p>而国家数据局的重要职责之一，就是拆掉数据烟囱。这么一来，首先受益的，就是老百姓。</p><p>比如，曾经出过这么一件事。一个老人突然去世，留下的存款分布在几家银行，而且具体不知道是哪些。子女就只能把附近所有的银行，全跑一遍。但是，假如有数据互联，就能一键查询到所有存款。<br>再比如，去医院看病。现在很多医院与医院之间的数据没有打通，患者每换个医院，同样的手续就得再走一遍。假如数据打通，这些问题也能解决。</p><p>在这里，要特别说一句。打通这些数据，工作量极大，需要非常深度的统筹协调。而这个工作，依靠任何民间的商业机构，都无法完成，必须由政府出面统筹。比如，很多原始数据中，<br>包含公民的个人隐私，或者跟国家安全有关的信息。对数据的利用，就要经过大量的清洗工作，不仅成本高，而且牵扯到数据安全和个人隐私。假如企业做，大家肯定不放心，因此需要政府牵头。</p><p>而拆掉数据烟囱，另一个关键的受益者，就是企业。</p><p>比如，对房地产领域来说，假如能拿到水泥、钢铁、玻璃、铝合金等生产数据，汇集起来，就能精准计算出开工到竣工的完整周期信息。再比如，相关的医疗病症数据，对医药研发来说，就非常关键。<br>再比如，电信、燃气、供电之类反映用户行为的数据，对很多企业都有用。而在这回数字中国的顶层规划中，已经明确，要推动公共数据汇聚利用，建设公共卫生、科技、教育等重要领域国家数据资源库。</p><p>北大数字金融研究中心的副主任沈艳老师，还从金融的角度分析过，数字中国顶层设计对中小微企业的促进作用。比如，过去中小微企业要贷款，虽然现在国家已经出台了很多扶持性政策，<br>但是，能否获得贷款，最重要的依据，还是看盈利。这是因为，除了盈利，很难获得其他方面的参考数据。但是，假如这些企业的数据能全面打通呈现，就意味着，在信用度量方面，或许可以建立新的指标，<br>让企业更容易拿到贷款。</p><p>借用沈艳老师的说法，这回政府要解决的重点问题之一，就是公共数据，应该由谁开发、如何汇聚、怎样利用的问题。</p><p>简单说，大数据的关键，就在于一个“大”字。要实现这个“大”，就需要大规划、大设计、大统筹。而要想在安全、公平、高效的前提下，完成这件事，就必须由政府出面，做好顶层设计。</p><p>总结一下，《数字中国建设整体布局规划》，与后面的组建国家数据局，是一脉相承的动作。反映了政府在数字中国建设方面，承担的职能将从在后监管，变成带头统筹，带头建设。<br>而当前的工作重点之一，是打通数据烟囱，盘活存量数据。在这个过程中，企业和个人，都将直接受益。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>未来已来</title>
    <link href="/2023/04/18/%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5/"/>
    <url>/2023/04/18/%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="文献集锦"><a href="#文献集锦" class="headerlink" title="文献集锦"></a>文献集锦</h1><h2 id="“Transformer”概念通俗易懂介绍"><a href="#“Transformer”概念通俗易懂介绍" class="headerlink" title="“Transformer”概念通俗易懂介绍"></a>“Transformer”概念通俗易懂介绍</h2><p><a href="https://jalammar.github.io/illustrated-transformer/">https://jalammar.github.io/illustrated-transformer/</a></p><h2 id="CS324提供了关于大型语言模型建模、理论、伦理和系统方面的基础知识，并且提供了亲自体验构建大模型的机会。"><a href="#CS324提供了关于大型语言模型建模、理论、伦理和系统方面的基础知识，并且提供了亲自体验构建大模型的机会。" class="headerlink" title="CS324提供了关于大型语言模型建模、理论、伦理和系统方面的基础知识，并且提供了亲自体验构建大模型的机会。"></a>CS324提供了关于大型语言模型建模、理论、伦理和系统方面的基础知识，并且提供了亲自体验构建大模型的机会。</h2><p><a href="https://stanford-cs324.github.io/winter2022/">https://stanford-cs324.github.io/winter2022/</a></p><h2 id="大模型家族详细介绍"><a href="#大模型家族详细介绍" class="headerlink" title="大模型家族详细介绍"></a>大模型家族详细介绍</h2><p><a href="https://lilianweng.github.io/posts/2023-01-27-the-transformer-family-v2/">https://lilianweng.github.io/posts/2023-01-27-the-transformer-family-v2/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DISC</title>
    <link href="/2023/04/16/DISC%E8%A1%8C%E4%B8%BA%E9%A3%8E%E6%A0%BC/"/>
    <url>/2023/04/16/DISC%E8%A1%8C%E4%B8%BA%E9%A3%8E%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="DISC理论"><a href="#DISC理论" class="headerlink" title="DISC理论"></a>DISC理论</h1><img src="/2023/04/16/DISC%E8%A1%8C%E4%B8%BA%E9%A3%8E%E6%A0%BC/DISC.png" class="" title="图片引用方法一"><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">DISC行为理论将人们的行为分为四种类型：支配型（D）、影响型（I）、稳健型（S）和谨慎型（C）。<br><br>支配型的人通常是决断力强、自信、目标导向的；影响型的人通常是外向、激情洋溢、有说服力的；稳健型的人通常是耐心、勤奋、稳定的；谨慎型的人通常是精确、有条理、注重细节的。<br><br>DISC行为理论可以帮助人们更好地理解自己和他人的行为样式，从而提高沟通和协作效率。DISC行为理论可以应用于很多领域，如领导力发展、团队建设、销售和招聘等。<br>DISC行为理论并不是一种“标签”，而是一种分类方法，它并不是用来对人进行评价，而是用来帮助我们更好地理解人。DISC行为理论并不是一种“刻板印象”，每个人都是独一无二的，<br>我们在使用DISC行为理论时应该尊重每个人的差异性。DISC行为理论可以帮助我们更好地了解自己的行为样式和优势，并且可以帮助我们学会如何适应和与不同类型的人相处。<br>DISC行为理论不仅适用于个人，也适用于团队和组织，它可以帮助我们更好地了解和管理团队和组织中的不同人员的行为样式和优势。<br><br></code></pre></td></tr></table></figure><h2 id="四种行为风格倾向性"><a href="#四种行为风格倾向性" class="headerlink" title="四种行为风格倾向性"></a>四种行为风格倾向性</h2><img src="/2023/04/16/DISC%E8%A1%8C%E4%B8%BA%E9%A3%8E%E6%A0%BC/DISC001.png" class="" title="图片引用方法一"><h2 id="不同风格的典型反应"><a href="#不同风格的典型反应" class="headerlink" title="不同风格的典型反应"></a>不同风格的典型反应</h2><img src="/2023/04/16/DISC%E8%A1%8C%E4%B8%BA%E9%A3%8E%E6%A0%BC/DISC002.png" class="" title="图片引用方法一">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java [1]创建和销毁对象-用静态工厂方法代替构造器</title>
    <link href="/2023/04/08/Effective-Java-1-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/04/08/Effective-Java-1-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="第1条-用静态工厂方法代替构造器"><a href="#第1条-用静态工厂方法代替构造器" class="headerlink" title="第1条 用静态工厂方法代替构造器"></a>第1条 用静态工厂方法代替构造器</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">静态工厂方法是一种替代构造器的方式。它是一个静态方法，<br>可以用于创建和返回类的实例。<br>与构造器不同的是，静态工厂方法可以有自己的名称，可以返回不同类型的对象，<br>并且可以缓存对象以提高性能。<br></code></pre></td></tr></table></figure><h3 id="1-静态工厂方法的优点包括"><a href="#1-静态工厂方法的优点包括" class="headerlink" title="1.静态工厂方法的优点包括"></a>1.静态工厂方法的<font color=red>优点</font>包括</h3><p>1.名称可以清晰地表达返回的对象类型和含义。<br>2.可以隐藏构造器，使类的实现更加灵活。<br>3.可以返回缓存的对象，避免重复创建对象。<br>4.可以返回子类的对象，实现接口的多态性。<br>5.可以根据不同的参数返回不同的对象。</p><h3 id="2-静态工厂方法的缺点包括"><a href="#2-静态工厂方法的缺点包括" class="headerlink" title="2.静态工厂方法的缺点包括"></a>2.静态工厂方法的<font color=red>缺点</font>包括</h3><p>1.静态工厂方法可能会与其他静态方法混淆，使代码难以理解<br>2.静态工厂方法可能会导致类的实现变得复杂。<br>3.静态工厂方法的名称可能不够直观，需要进行文档化说明。</p><p><font color=#008000>总的来说，静态工厂方法是一种有用的替代构造器的方式，可以使类的实现更加灵活和可维护。但是，是否使用静态工厂方法还需要根据具体情况进行判断。</font></p><h3 id="3-具体示例"><a href="#3-具体示例" class="headerlink" title="3.具体示例"></a>3.具体示例</h3><p>假设我们有一个类叫做Person，我们可以使用静态工厂方法代替构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Person <span class="hljs-title function_">createPerson</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(name, age);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用了一个名为createPerson的静态工厂方法来创建Person对象。这个方法接受一个name和age参数，并返回一个新的Person对象。我们也可以添加一些额外的逻辑，例如缓存对象或者返回子类的对象。<br>使用静态工厂方法创建Person对象的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> Person.createPerson(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> person.getName(); <span class="hljs-comment">// 返回 &quot;Tom&quot;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> person.getAge(); <span class="hljs-comment">// 返回 25</span><br></code></pre></td></tr></table></figure><p>可以看到，使用静态工厂方法创建对象非常简单，而且可以使代码更加清晰和易于维护。<br>静态工厂方法在Java的类库中非常常见，以下是一些例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">java.util.Collections类中有很多静态工厂方法，例如emptyList()和singletonList()，它们用于创建空List和只包含一个元素的List。<br>java.nio.charset.Charset类中有一个静态工厂方法forName()，它用于获取Charset对象。<br>java.util.EnumSet类中有两个静态工厂方法of()和range()，它们用于创建枚举类型的集合。<br>java.util.regex.Pattern类中有一个静态工厂方法compile()，它用于编译正则表达式并返回一个Pattern对象。<br>java.security.KeyFactory类中有一个静态工厂方法getInstance()，它用于获取KeyFactory对象。<br></code></pre></td></tr></table></figure><p>这些都是Java类库中使用静态工厂方法的例子，它们在实际开发中都非常有用。</p><h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4.QA"></a>4.QA</h3><h4 id="4-1-现在绝大多数对象都是由-spring-容器来管理了，静态工厂创建对象用的多吗？"><a href="#4-1-现在绝大多数对象都是由-spring-容器来管理了，静态工厂创建对象用的多吗？" class="headerlink" title="4.1 现在绝大多数对象都是由 spring 容器来管理了，静态工厂创建对象用的多吗？"></a><font color=Blue>4.1 现在绝大多数对象都是由 spring 容器来管理了，静态工厂创建对象用的多吗？</font></h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">1、Spring框架本身也使用了静态工厂方法来创建一些对象，例如RestTemplate和JdbcTemplate等。<br>2、在一些情况下，我们可能无法使用Spring容器来创建对象，例如在没有使用Spring的Java应用程序中创建对象。此时，我们可以使用静态工厂方法来创建对象。<br>3、在某些情况下，我们需要在运行时动态决定创建哪个类的对象。这时静态工厂方法也能胜任。<br>4、静态工厂方法可以隐藏对象创建过程中的复杂性，并将其抽象化，使得客户端代码更加简洁和易于维护。<br>5、静态工厂方法基于名称，可以返回不同的实现类对象，这样就可以在不改变客户端代码的情况下，灵活地切换不同的实现类对象。<br></code></pre></td></tr></table></figure><p>总之，虽然Spring框架提供了强大的对象管理功能，但静态工厂方法还是有其使用场景和优点的。</p><h4 id="4-2-有哪些类应该用静态工厂方法代替构造器？"><a href="#4-2-有哪些类应该用静态工厂方法代替构造器？" class="headerlink" title="4.2 有哪些类应该用静态工厂方法代替构造器？"></a><font color=Blue>4.2 有哪些类应该用静态工厂方法代替构造器？</font></h4><p>通常情况下，以下情况适合使用静态工厂方法代替构造器：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">1、当类需要有多个构造器时，使用静态工厂方法可以提供更加易于理解和使用的构造器名称。<br>2、当创建对象的过程比较复杂或需要进行复杂的初始化操作时，静态工厂方法可以将初始化逻辑封装起来，让客户端代码更加简洁和易于维护。<br>3、当需要动态切换不同实现类的实例时，静态工厂方法可以通过名称来进行实例的获取，而无需直接调用构造器。<br>4、当类需要进行缓存对象时，静态工厂方法可以通过缓存机制避免重复创建对象，提高性能。<br>5、当需要控制类实例的数量时，静态工厂方法可以通过限制实例数量来控制程序的资源消耗。<br></code></pre></td></tr></table></figure><p>例如，Java中的Collections类就是通过静态工厂方法来创建List、Set、Map等集合类对象的。另外，Java中的Calendar类也通过静态工厂方法来创建对象，例如getInstance()方法。</p><h4 id="4-3-有哪些类的实例应该缓存，而不用每次新建？"><a href="#4-3-有哪些类的实例应该缓存，而不用每次新建？" class="headerlink" title="4.3 有哪些类的实例应该缓存，而不用每次新建？"></a><font color=Blue>4.3 有哪些类的实例应该缓存，而不用每次新建？</font></h4><p>以下是一些建议缓存实例的类：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">1、不可变对象：由于不可变对象在创建后就不会再改变，因此可以缓存实例，避免重复创建。<br>2、大量使用的对象：例如线程池、数据库连接池等对象，由于创建和销毁对象会造成较大的资源开销，因此可以缓存实例，重复利用。<br>3、昂贵创建的对象：例如网络连接、文件IO等操作，由于创建和销毁对象都需要时间和资源，因此可以缓存实例，重复利用。<br>4、单例模式的对象：由于单例模式的对象只有一个实例，因此可以缓存实例，避免重复创建。<br></code></pre></td></tr></table></figure><p>需要注意的是，如果缓存的实例不再使用，需要及时清理，避免占用过多的内存空间。另外，为了保证缓存的实例的线程安全性，可以考虑使用线程安全的数据结构，如ConcurrentHashMap等。</p><h4 id="4-4-有哪些代码应该用接口代替子类型，且子类型可以不对外暴露？"><a href="#4-4-有哪些代码应该用接口代替子类型，且子类型可以不对外暴露？" class="headerlink" title="4.4 有哪些代码应该用接口代替子类型，且子类型可以不对外暴露？"></a><font color=Blue>4.4 有哪些代码应该用接口代替子类型，且子类型可以不对外暴露？</font></h4><p>以下是一些应该用接口代替子类型的情况，且子类型可以不对外暴露的代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">1、服务提供者接口（Service Provider Interface，SPI）：在实现SPI时，通常会定义接口和实现类，实现类不对外暴露，而是由其对应的接口进行暴露。<br>这样做可以让实现类的实现细节被封装，同时也可以让应用程序可以灵活地选择具体的实现类，而无需修改代码。<br>2、抽象工厂模式：在抽象工厂模式中，工厂类通过接口暴露创建对象的方法，具体的产品实现类不对外暴露。这样做可以让客户端代码只依赖于抽象接口，<br>而不依赖于具体实现类，从而实现了松耦合。<br>3、适配器模式：在适配器模式中，适配器实现了目标接口，并通过委托方式调用适配者的方法。在这种情况下，适配者不需要对外暴露，因为适配器已经将其封装起来了。<br>4、桥接模式：在桥接模式中，抽象部分（Abstraction）通过接口暴露行为，具体部分（Implementor）不对外暴露。这样做可以使得抽象部分与具体部分相互独立，从而可以灵活地进行组合。<br></code></pre></td></tr></table></figure><p>需要注意的是，虽然子类型可以不对外暴露，但仍然需要保证其被正确地实现和使用。因此，在定义接口时，应该清楚地定义接口的规范和使用方式，以确保其正确性和可靠性。<br>具体示例如下：<br><font color=gray>一个简单的图形库，其中包含图形（如圆形、矩形、三角形等）和绘制器（如画笔、填充器等）两个概念。<br>在这种情况下，可以定义一个图形接口和一个绘制器接口，具体的图形实现类和绘制器实现类不对外暴露，而是由其对应的接口进行暴露。</font><br>例如，定义一个绘制圆形的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(DrawingTool tool)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，DrawingTool是一个绘制器接口，定义了绘制器的方法。<br>然后，定义一个具体的圆形实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x, y, radius;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CircleImpl</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(DrawingTool tool)</span> &#123;<br>        tool.drawCircle(x, y, radius);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，draw方法接受一个DrawingTool参数，用于绘制圆形。<br>最后，定义一个绘制器接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DrawingTool</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> radius)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawRectangle</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawTriangle</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> x3, <span class="hljs-type">int</span> y3)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下，具体的绘制器实现类不需要对外暴露，因为它们的方法都是由DrawingTool接口定义的。客户端可以使用如下代码来绘制圆形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DrawingTool</span> <span class="hljs-variable">tool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDrawingTool</span>();<br><span class="hljs-type">Circle</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleImpl</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>);<br>circle.draw(tool);<br></code></pre></td></tr></table></figure><p>其中，MyDrawingTool是一个具体的绘制器实现类，不需要对外暴露。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/07/hello-world/"/>
    <url>/2023/04/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br>hexo new post 测试文章<br><br><br>本地启动<br>hexo g -d<br>hexo s<br><br>安装hexo-deployer-git<br><br>npm install hexo-deployer-git --save<br><br>部署到GitHub<br><br>hexo g -d<br><br>参考文章地址https://blog.csdn.net/yaorongke/article/details/119089190<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>米芾书法</title>
    <link href="/2021/06/10/%E7%B1%B3%E8%8A%BE%E4%B9%A6%E6%B3%95/"/>
    <url>/2021/06/10/%E7%B1%B3%E8%8A%BE%E4%B9%A6%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/2021/06/10/%E7%B1%B3%E8%8A%BE%E4%B9%A6%E6%B3%95/MF.png" class="" title="图片引用方法一">]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
