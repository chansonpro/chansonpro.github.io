<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Effective Java [1]创建和销毁对象-用静态工厂方法代替构造器</title>
    <link href="/2023/04/08/Effective-Java-1-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/04/08/Effective-Java-1-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="第1条-用静态工厂方法代替构造器"><a href="#第1条-用静态工厂方法代替构造器" class="headerlink" title="第1条 用静态工厂方法代替构造器"></a>第1条 用静态工厂方法代替构造器</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">静态工厂方法是一种替代构造器的方式。它是一个静态方法，<br>可以用于创建和返回类的实例。<br>与构造器不同的是，静态工厂方法可以有自己的名称，可以返回不同类型的对象，<br>并且可以缓存对象以提高性能。<br></code></pre></td></tr></table></figure><h3 id="1-静态工厂方法的优点包括"><a href="#1-静态工厂方法的优点包括" class="headerlink" title="1.静态工厂方法的优点包括"></a>1.静态工厂方法的<font color=red>优点</font>包括</h3><p>1.名称可以清晰地表达返回的对象类型和含义。<br>2.可以隐藏构造器，使类的实现更加灵活。<br>3.可以返回缓存的对象，避免重复创建对象。<br>4.可以返回子类的对象，实现接口的多态性。<br>5.可以根据不同的参数返回不同的对象。</p><h3 id="2-静态工厂方法的缺点包括"><a href="#2-静态工厂方法的缺点包括" class="headerlink" title="2.静态工厂方法的缺点包括"></a>2.静态工厂方法的<font color=red>缺点</font>包括</h3><p>1.静态工厂方法可能会与其他静态方法混淆，使代码难以理解<br>2.静态工厂方法可能会导致类的实现变得复杂。<br>3.静态工厂方法的名称可能不够直观，需要进行文档化说明。</p><h3 id="总的来说，静态工厂方法是一种有用的替代构造器的方式，可以使类的实现更加灵活和可维护。但是，是否使用静态工厂方法还需要根据具体情况进行判断。"><a href="#总的来说，静态工厂方法是一种有用的替代构造器的方式，可以使类的实现更加灵活和可维护。但是，是否使用静态工厂方法还需要根据具体情况进行判断。" class="headerlink" title="总的来说，静态工厂方法是一种有用的替代构造器的方式，可以使类的实现更加灵活和可维护。但是，是否使用静态工厂方法还需要根据具体情况进行判断。"></a><font color=#008000>总的来说，静态工厂方法是一种有用的替代构造器的方式，可以使类的实现更加灵活和可维护。但是，是否使用静态工厂方法还需要根据具体情况进行判断。</font></h3><h3 id="3-具体示例"><a href="#3-具体示例" class="headerlink" title="3.具体示例"></a>3.具体示例</h3><p>假设我们有一个类叫做Person，我们可以使用静态工厂方法代替构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Person <span class="hljs-title function_">createPerson</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(name, age);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用了一个名为createPerson的静态工厂方法来创建Person对象。这个方法接受一个name和age参数，并返回一个新的Person对象。我们也可以添加一些额外的逻辑，例如缓存对象或者返回子类的对象。<br>使用静态工厂方法创建Person对象的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> Person.createPerson(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> person.getName(); <span class="hljs-comment">// 返回 &quot;Tom&quot;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> person.getAge(); <span class="hljs-comment">// 返回 25</span><br></code></pre></td></tr></table></figure><p>可以看到，使用静态工厂方法创建对象非常简单，而且可以使代码更加清晰和易于维护。<br>静态工厂方法在Java的类库中非常常见，以下是一些例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">java.util.Collections类中有很多静态工厂方法，例如emptyList()和singletonList()，它们用于创建空List和只包含一个元素的List。<br>java.nio.charset.Charset类中有一个静态工厂方法forName()，它用于获取Charset对象。<br>java.util.EnumSet类中有两个静态工厂方法of()和range()，它们用于创建枚举类型的集合。<br>java.util.regex.Pattern类中有一个静态工厂方法compile()，它用于编译正则表达式并返回一个Pattern对象。<br>java.security.KeyFactory类中有一个静态工厂方法getInstance()，它用于获取KeyFactory对象。<br></code></pre></td></tr></table></figure><p>这些都是Java类库中使用静态工厂方法的例子，它们在实际开发中都非常有用。</p><h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4.QA"></a>4.QA</h3><h4 id="4-1-现在绝大多数对象都是由-spring-容器来管理了，静态工厂创建对象用的多吗？"><a href="#4-1-现在绝大多数对象都是由-spring-容器来管理了，静态工厂创建对象用的多吗？" class="headerlink" title="4.1 现在绝大多数对象都是由 spring 容器来管理了，静态工厂创建对象用的多吗？"></a><font color=Blue>4.1 现在绝大多数对象都是由 spring 容器来管理了，静态工厂创建对象用的多吗？</font></h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">1、Spring框架本身也使用了静态工厂方法来创建一些对象，例如RestTemplate和JdbcTemplate等。<br>2、在一些情况下，我们可能无法使用Spring容器来创建对象，例如在没有使用Spring的Java应用程序中创建对象。此时，我们可以使用静态工厂方法来创建对象。<br>3、在某些情况下，我们需要在运行时动态决定创建哪个类的对象。这时静态工厂方法也能胜任。<br>4、静态工厂方法可以隐藏对象创建过程中的复杂性，并将其抽象化，使得客户端代码更加简洁和易于维护。<br>5、静态工厂方法基于名称，可以返回不同的实现类对象，这样就可以在不改变客户端代码的情况下，灵活地切换不同的实现类对象。<br></code></pre></td></tr></table></figure><p>总之，虽然Spring框架提供了强大的对象管理功能，但静态工厂方法还是有其使用场景和优点的。</p><h4 id="4-2-有哪些类应该用静态工厂方法代替构造器？"><a href="#4-2-有哪些类应该用静态工厂方法代替构造器？" class="headerlink" title="4.2 有哪些类应该用静态工厂方法代替构造器？"></a><font color=Blue>4.2 有哪些类应该用静态工厂方法代替构造器？</font></h4><p>通常情况下，以下情况适合使用静态工厂方法代替构造器：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">1、当类需要有多个构造器时，使用静态工厂方法可以提供更加易于理解和使用的构造器名称。<br>2、当创建对象的过程比较复杂或需要进行复杂的初始化操作时，静态工厂方法可以将初始化逻辑封装起来，让客户端代码更加简洁和易于维护。<br>3、当需要动态切换不同实现类的实例时，静态工厂方法可以通过名称来进行实例的获取，而无需直接调用构造器。<br>4、当类需要进行缓存对象时，静态工厂方法可以通过缓存机制避免重复创建对象，提高性能。<br>5、当需要控制类实例的数量时，静态工厂方法可以通过限制实例数量来控制程序的资源消耗。<br></code></pre></td></tr></table></figure><p>例如，Java中的Collections类就是通过静态工厂方法来创建List、Set、Map等集合类对象的。另外，Java中的Calendar类也通过静态工厂方法来创建对象，例如getInstance()方法。</p><h4 id="4-3-有哪些类的实例应该缓存，而不用每次新建？"><a href="#4-3-有哪些类的实例应该缓存，而不用每次新建？" class="headerlink" title="4.3 有哪些类的实例应该缓存，而不用每次新建？"></a><font color=Blue>4.3 有哪些类的实例应该缓存，而不用每次新建？</font></h4><p>以下是一些建议缓存实例的类：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">1、不可变对象：由于不可变对象在创建后就不会再改变，因此可以缓存实例，避免重复创建。<br>2、大量使用的对象：例如线程池、数据库连接池等对象，由于创建和销毁对象会造成较大的资源开销，因此可以缓存实例，重复利用。<br>3、昂贵创建的对象：例如网络连接、文件IO等操作，由于创建和销毁对象都需要时间和资源，因此可以缓存实例，重复利用。<br>4、单例模式的对象：由于单例模式的对象只有一个实例，因此可以缓存实例，避免重复创建。<br></code></pre></td></tr></table></figure><p>需要注意的是，如果缓存的实例不再使用，需要及时清理，避免占用过多的内存空间。另外，为了保证缓存的实例的线程安全性，可以考虑使用线程安全的数据结构，如ConcurrentHashMap等。</p><h4 id="4-4-有哪些代码应该用接口代替子类型，且子类型可以不对外暴露？"><a href="#4-4-有哪些代码应该用接口代替子类型，且子类型可以不对外暴露？" class="headerlink" title="4.4 有哪些代码应该用接口代替子类型，且子类型可以不对外暴露？"></a><font color=Blue>4.4 有哪些代码应该用接口代替子类型，且子类型可以不对外暴露？</font></h4><p>以下是一些应该用接口代替子类型的情况，且子类型可以不对外暴露的代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">1、服务提供者接口（Service Provider Interface，SPI）：在实现SPI时，通常会定义接口和实现类，实现类不对外暴露，而是由其对应的接口进行暴露。<br>这样做可以让实现类的实现细节被封装，同时也可以让应用程序可以灵活地选择具体的实现类，而无需修改代码。<br>2、抽象工厂模式：在抽象工厂模式中，工厂类通过接口暴露创建对象的方法，具体的产品实现类不对外暴露。这样做可以让客户端代码只依赖于抽象接口，<br>而不依赖于具体实现类，从而实现了松耦合。<br>3、适配器模式：在适配器模式中，适配器实现了目标接口，并通过委托方式调用适配者的方法。在这种情况下，适配者不需要对外暴露，因为适配器已经将其封装起来了。<br>4、桥接模式：在桥接模式中，抽象部分（Abstraction）通过接口暴露行为，具体部分（Implementor）不对外暴露。这样做可以使得抽象部分与具体部分相互独立，从而可以灵活地进行组合。<br></code></pre></td></tr></table></figure><p>需要注意的是，虽然子类型可以不对外暴露，但仍然需要保证其被正确地实现和使用。因此，在定义接口时，应该清楚地定义接口的规范和使用方式，以确保其正确性和可靠性。<br>具体示例如下：<br><font color=gray>一个简单的图形库，其中包含图形（如圆形、矩形、三角形等）和绘制器（如画笔、填充器等）两个概念。<br>在这种情况下，可以定义一个图形接口和一个绘制器接口，具体的图形实现类和绘制器实现类不对外暴露，而是由其对应的接口进行暴露。</font><br>例如，定义一个绘制圆形的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(DrawingTool tool)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，DrawingTool是一个绘制器接口，定义了绘制器的方法。<br>然后，定义一个具体的圆形实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x, y, radius;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CircleImpl</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(DrawingTool tool)</span> &#123;<br>        tool.drawCircle(x, y, radius);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，draw方法接受一个DrawingTool参数，用于绘制圆形。<br>最后，定义一个绘制器接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DrawingTool</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawCircle</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> radius)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawRectangle</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawTriangle</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> x3, <span class="hljs-type">int</span> y3)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下，具体的绘制器实现类不需要对外暴露，因为它们的方法都是由DrawingTool接口定义的。客户端可以使用如下代码来绘制圆形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DrawingTool</span> <span class="hljs-variable">tool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDrawingTool</span>();<br><span class="hljs-type">Circle</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleImpl</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>);<br>circle.draw(tool);<br></code></pre></td></tr></table></figure><p>其中，MyDrawingTool是一个具体的绘制器实现类，不需要对外暴露。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/07/hello-world/"/>
    <url>/2023/04/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br>hexo new post 测试文章<br><br><br>本地启动<br>hexo g -d<br>hexo s<br><br>安装hexo-deployer-git<br><br>npm install hexo-deployer-git --save<br><br>部署到GitHub<br><br>hexo g -d<br><br>参考文章地址https://blog.csdn.net/yaorongke/article/details/119089190<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/2021/06/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/MF.png" class="" title="图片引用方法一">]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
